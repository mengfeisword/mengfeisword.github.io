<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>DocDock Theme for Hugo on DocDock Documentation</title>
    <link>/</link>
    <description>Recent content in DocDock Theme for Hugo on DocDock Documentation</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 17 Oct 2017 15:26:15 +0000</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Logo placeholder</title>
      <link>/content-organisation/logo/</link>
      <pubDate>Mon, 24 Apr 2017 18:36:24 +0200</pubDate>
      
      <guid>/content-organisation/logo/</guid>
      <description>Create a _header.md page in content folder. Its content is what you get in the logo placeholder (top left of the screen).
Tip : you can add a image, a combobox with links to other documentation&amp;hellip;.Tip 2 : look at extra static menu if you want to add links to other website in this sidebar</description>
    </item>
    
    <item>
      <title>compose命令详解</title>
      <link>/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/docker/compose%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/docker/compose%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</guid>
      <description> build(构建yml中某个服务的镜像) 如上，web这个服务是依赖于镜像build的。在本地 也存在Dockerfile文件。 可以使用docker-compose build来构建服务的镜像。 ps(查看已经启动的服务状态） kill(停止某个服务） logs(可以查看某个服务的log） port(打印绑定的public port） pull(pull服务镜像) up(启动yml定义的所有服务） stop(停止yml中定义的所有服务） start(启动被停止的yml中的所有服务） kill(强行停止yml中定义的所有服务） rm（删除yml中定义的所有服务） restart(重启yml中定义的所有服务） scale(扩展某个服务的个数，可以向上或向下） migrate-to-labels(这个没有实际尝试。根据介绍是将服务从1.2迁移到1.3带labels的版本。docker之前不支持label） version（查看compose的版本） </description>
    </item>
    
    <item>
      <title>docker save与docker export的区别</title>
      <link>/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/docker/docker-save%E4%B8%8Edocker-export%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/docker/docker-save%E4%B8%8Edocker-export%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>docker save与docker export的区别 一.docker save 1.docker save是用来将一个或多个image打包保存的工具。 docker save -o images.tar postgres:9.6 mongo:3.4
2.docker save如果指定的是container，docker save将保存的是容器背后的image。 docker save -o b.tar postgres
3.将打包后的镜像载入进来使用docker load docker load -i images.tar
4.docker save的应用场景是,如果你的应用是使用docker-compose.yml编排的多个镜像组合,但你要部署的客户服务器并不能连外网.这时,你可以使用docker save将用到的镜像打个包,然后拷贝到客户服务器上使用docker load载入.
二.docker export 1.docker export是用来将container的文件系统进行打包的 docker export需要指定container，不能像docker save那样指定image或container都可以。 docker export -o postgres-export.tar postgres
2.将打包的container载入进来使用docker import docker import将container导入后会成为一个image，而不是恢复为一个container。 docker import postgres-export.tar postgres:latest
另外一点是，docker import可以指定IMAGE[:TAG]，说明我们可以为镜像指定新名称。如果本地镜像库中已经存在同名的镜像，则原有镜像的名称将会被剥夺，赋给新的镜像。原有镜像将成为孤魂野鬼，只能通过IMAGE ID进行操作。
docker export的应用场景主要用来制作基础镜像，比如你从一个ubuntu镜像启动一个容器，然后安装一些软件和进行一些设置后，使用docker export保存为一个基础镜像。然后，把这个镜像分发给其他人使用，比如作为基础的开发环境。
三.docker save和docker export的区别 1.docker save保存的是镜像（image），docker export保存的是容器（container）； 2.docker load用来载入镜像包，docker import用来载入容器包，但两者都会恢复为镜像； 3.docker load不能对载入的镜像重命名，而docker import可以为镜像指定新名称。 </description>
    </item>
    
    <item>
      <title>etcd安装</title>
      <link>/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/etcd/etcd%E5%AE%89%E8%A3%85/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/etcd/etcd%E5%AE%89%E8%A3%85/</guid>
      <description>1.etec 安装 https://blog.csdn.net/Axela30W/article/details/84558730#t2 https://cizixs.com/2016/08/02/intro-to-etcd/ https://blog.csdn.net/huwh_/article/details/80225902 https://tonydeng.github.io/2015/10/19/etcd-application-scenarios/
https://tonydeng.github.io/categories/
etcdctl &amp;ndash;endpoints=[192.168.1.9:2389] get / &amp;ndash;prefix &amp;ndash;keys-only
看见候选包 brew search etcd
安装 brew install etcd
etcd 查询 ETCDCTL_API=3 etcdctl &amp;ndash;endpoints=http://192.168.1.19:2379 &amp;ndash;prefix &amp;ndash;keys-only=true get / ETCDCTL_API=3 etcdctl &amp;ndash;endpoints=http://192.168.1.19:2379 get + keys 查询键信息。
获取集群成员 ETCDCTL_API=3 etcdctl &amp;ndash;endpoints=http://127.0.0.1:30001 member list
设置数据 ETCDCTL_API=3 etcdctl &amp;ndash;endpoints=http://127.0.0.1:30001 put /root/test/keyOne &amp;ldquo;Hello etcd&amp;rdquo;
ETCDCTL_API=3 etcdctl &amp;ndash;endpoints=http://127.0.0.1:30001 &amp;ndash;prefix &amp;ndash;keys-only=true get / ETCDCTL_API=3 etcdctl &amp;ndash;endpoints=http://127.0.0.1:30001 get /root/test/keyOne</description>
    </item>
    
    <item>
      <title>Golang面试题41道</title>
      <link>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/golang%E9%9D%A2%E8%AF%95%E9%A2%9841%E9%81%93/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/golang%E9%9D%A2%E8%AF%95%E9%A2%9841%E9%81%93/</guid>
      <description>Golang面试题41道
什么是golang? go是一个开源的编程语言，由谷歌开发的。这门语言是设计用来做系统级的编程的。
为什么要用golang? 简单点说就是go是一个开源的编程语言，它很容易用来编写简单, 可靠，有效的软件。
是谁开发了go语言？ Robert Griesemer, Rob Pike, Ken Thompson.
go编程中的packages是什么？ Go语言的最小集合就是package，它的程序入口是main package。
Go语言是否支持generic编程? 不支持。
go语言是大小写敏感的编程语言吗？ 是的。
go语言里面字符串的语法是怎样的？ go语言里有两种字符串语法。 一种是原始字符串语法raw string literals。使用back quotes来包含一系列的字符集。支持多行。 另一种是interpreted string literals。用双引号括起来。不支持多行。
Go语言的work space是指什么? Work space用来包含go语言的代码，有三个主要的文件目录, src, pkg, bin。
go语言中布尔类型的缺省值是什么？ false
Gopath环境变量是什么? Gopath来指定工作空间的位置。在做go语言编程的时候，这个变量设置是必须的。
go语言编程的好处是什么？ 编译和运行都很快。 在语言层级支持并行操作。 有垃圾处理器。 内置字符串和maps。 函数是go语言的最基本编程单位。
go语言里比较常用的功能模块。 Container, container list, container heap. Web server, net/http Cryptography, Crypto/md5, crypto/sha1. Compression, compress/gzip. Database, database/sql.
goroutine是什么？ 一个goroutine是可以跟其他函数并行运行的函数。如果想停止一个goroutine，你可以通过一个signal channel传值进去。
如何写多行的字符串？ raw string literal
go语言里的break是干什么用的？ Break是用来终止当前的for loop或者switch的。</description>
    </item>
    
    <item>
      <title>golang面试题整理</title>
      <link>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/golang%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/golang%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/</guid>
      <description>golang面试题整理
go的调度
go struct能不能比较 因为是强类型语言，所以不同类型的结构不能作比较，但是同一类型的实例值是可以比较的，实例不可以比较，因为是指针类型
go defer（for defer），先进后出，后进先出 func b() { for i := 0; i &amp;lt; 4; i++ { defer fmt.Print(i) } }
select可以用于什么，常用语gorotine的完美退出 golang 的 select 就是监听 IO 操作，当 IO 操作发生时，触发相应的动作每个case语句里必须是一个IO操作，确切的说，应该是一个面向channel的IO操作
context包的用途 Context通常被译作上下文，它是一个比较抽象的概念，其本质，是【上下上下】存在上下层的传递，上会把内容传递给下。在Go语言中，程序单元也就指的是Goroutine
client如何实现长连接 server是设置超时时间，for循环遍历的
主协程如何等其余协程完再操作 使用channel进行通信，context,select
slice，len，cap，共享，扩容 append 函数，因为slice底层数据结构是，由数组、len、cap组成，所以，在使用append扩容时，会查看数组后面有没有连续内存快，有就在后面添加，没有就重新生成一个大的素组
map如何顺序读取 map不能顺序读取，是因为他是无序的，想要有序读取，首先的解决的问题就是，把ｋｅｙ变为有序，所以可以把key放入切片，对切片进行排序，遍历切片，通过key取值。
实现set
实现消息队列（多生产者，多消费者） 使用切片加锁可以实现
大文件排序 归并排序，分而治之,拆分为小文件，再排序
基本排序，哪些是稳定的
http get跟head HEAD和GET本质是一样的，区别在于HEAD不含有呈现数据，而仅仅是HTTP头信息。有的人可能觉得这个方法没什么用，其实不是这样的。想象一个业务情景：欲判断某个资源是否存在，我们通常使用GET，但这里用HEAD则意义更加明确。
http 401,403 400 bad request，请求报文存在语法错误 401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息 403 forbidden，表示对请求资源的访问被服务器拒绝 404 not found，表示在服务器上没有找到请求的资源
http keep-alive client发出的HTTP请求头需要增加Connection:keep-alive字段 Web-Server端要能识别Connection:keep-alive字段，并且在http的response里指定Connection:keep-alive字段，告诉client，我能提供keep-alive服务，并且&amp;quot;应允&amp;quot;client我暂时不会关闭socket连接</description>
    </item>
    
    <item>
      <title>Golang面试题目全网超全超详细的口语化解答总结</title>
      <link>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/golang%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E5%85%A8%E7%BD%91%E8%B6%85%E5%85%A8%E8%B6%85%E8%AF%A6%E7%BB%86%E7%9A%84%E5%8F%A3%E8%AF%AD%E5%8C%96%E8%A7%A3%E7%AD%94%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/golang%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E5%85%A8%E7%BD%91%E8%B6%85%E5%85%A8%E8%B6%85%E8%AF%A6%E7%BB%86%E7%9A%84%E5%8F%A3%E8%AF%AD%E5%8C%96%E8%A7%A3%E7%AD%94%E6%80%BB%E7%BB%93/</guid>
      <description>【2022版】Golang面试题目全网超全超详细的口语化解答总结 【2022版】 Golang面试题目全网超全总结
1 特性篇 1.1 Golang 使用什么数据类型？ 布尔型、数值型(整型、浮点型)、字符串、指针、数组、结构体、切片、map、chan、接口、函数 1.2 字符串的小问题 ①可以用==比较 ②不可以通过下标的方式改变某个字符，字符串是只读的 ③不能和nil比较 1.3 数组定义问题 数组是可以以指定下标的方式定义的，例如： array := [...]int{1,2,3,9:34} 表示array[9]==34 则len(array)就是10 来看一道题目： 1.对 rune 字面量的理解和数组的语法 2.常量表达式这个规则应该了解下 package main import ( &amp;#34;fmt&amp;#34; ) func main() { m := [...]int{ &amp;#39;a&amp;#39;: 1, &amp;#39;b&amp;#39;: 2, &amp;#39;c&amp;#39;: 3, } m[&amp;#39;a&amp;#39;] = 3 fmt.Println(len(m)) } 输出：100 原因：以下标的方式定义数组内的元素，&amp;#39;c’的ascll为99，故长度为100。 1.4 内存四区 代码区：存放代码 全局区：常量+全局变量。最终在进程退出时，由操作系统回收。 堆区：空间充裕，数据存放时间较久。一般由开发者分配，启动Golang的GC由GC清除机制自动回收。 栈区：空间较小，要求数据读写性能高，数据存放时间较短暂。由编译器自动分配和释放，存放函数的参数值、局部变量、返回值等、局部变量等(局部变量如果产生逃逸现象，可能会挂在在堆区) 1.5 Go 支持什么形式的类型转换？ Go支持显示类型的转换，以满足严格的类型要求 1.6 空结构体的作用 不包含任何字段的结构体叫做空结构体 struct{} 定义： var et struct{} et := struct{}{} type ets struct {} / et := ets{} / var et ets 特性： 所有的空结构体的地址都是同一地址，都是zerobase的地址，且大小为0 使用场景： 1.</description>
    </item>
    
    <item>
      <title>Golang面试题目全网超全超详细的口语化解答总结</title>
      <link>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/golang%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E5%85%A8%E7%BD%91%E8%B6%85%E5%85%A8%E8%B6%85%E8%AF%A6%E7%BB%86%E7%9A%84%E5%8F%A3%E8%AF%AD%E5%8C%96%E8%A7%A3%E7%AD%94%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/golang%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E5%85%A8%E7%BD%91%E8%B6%85%E5%85%A8%E8%B6%85%E8%AF%A6%E7%BB%86%E7%9A%84%E5%8F%A3%E8%AF%AD%E5%8C%96%E8%A7%A3%E7%AD%94%E6%80%BB%E7%BB%93/</guid>
      <description>【2022版】 Golang面试题目全网超全总结
特性篇 1.1 Golang 使用什么数据类型？ 1.2 字符串的小问题 1.3 数组定义问题 1.4 内存四区 1.5 Go 支持什么形式的类型转换？ 1.6 空结构体的作用 1.7 单引号，双引号，反引号的区别？ 1.8 如何停止一个 Goroutine？ 1.9 Go 语言中 cap 函数可以作用于哪些内容？ 1.10 Printf()，Sprintf()，FprintF() 都是格式化输出，有什么不同？ 1.11 golang 中 make 和 new 的区别？（基本必问） 1.12 关于Go中值类型、引用类型、值传递、引用传递的疑惑 2.特性篇 2.1 for-range切片的时候，它的地址会发生变化么？ 2.2 context 使用场景和用途？ 2.3 常量计数器iota 2.4 defer特性相关 2.5 介绍下rune类型 2.6 interface相关问题 2.6.1 介绍一下interface 2.6.2 值接收者和指针接收者（值调用者和指针调用者） 2.6.3 接口的类型检查 2.6.3.1 方法 2.6.3.2 小题目 2.6.4 空接口 2.6.5 go语言如何实现面对对象编程 2.7. 反射的相关问题 2.7.1 Go的反射包怎么找到对应的方法 2.</description>
    </item>
    
    <item>
      <title>go语言面试要点</title>
      <link>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/go%E8%AF%AD%E8%A8%80%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/go%E8%AF%AD%E8%A8%80%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9/</guid>
      <description>切片slice 通道channel(无缓冲和有缓冲) select 延迟defer 闭包 进程和线程，并发和并行，携程和线程 GPM 锁与同步 sync(5个)和atomic interface不是指针 结构 面向接口编程 Interface Goroutine (依赖于信号的、高并发低开销的并发模型，大概是Golang最大特色) Defer和Panic函数 CGO(Golang的底层沟通能力是非常强的,但要用好需要躲过很多坑) Golang自身的内存管理机制</description>
    </item>
    
    <item>
      <title>go语言面试题</title>
      <link>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/go%E8%AF%AD%E8%A8%80%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/go%E8%AF%AD%E8%A8%80%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>go语言面试题</description>
    </item>
    
    <item>
      <title>Installation</title>
      <link>/getting-start/installation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/getting-start/installation/</guid>
      <description>&lt;div class=&#34;alert alert-warning&#34; role=&#34;alert&#34;&gt;HUGO &lt;strong&gt;v0.32&lt;/strong&gt; minimum required to use this theme&lt;/div&gt;

&lt;p&gt;The following steps are here to help you initialize your new website. If you don’t know Hugo at all, we strongly suggest you to train by following this &lt;a href=&#34;https://gohugo.io/overview/quickstart/&#34;&gt;great documentation for beginners&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>k8s</title>
      <link>/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/k8s/k8s/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/k8s/k8s/</guid>
      <description>k8s k8s 简介 Kubernetes Pod概述 K8s 学习者绝对不能错过的最全知识图谱（内含 58个知识点链接）
1.master(控制系统) etcd: k-v 数据库（用于配置共享和服务发现） 只与 apiserver 通信 scheduler: 调度 简单点说就是给一个 pod 找一个 node(合理的平衡) controller manager: 核心，负责将现在的状态调整为 etcd 上应该的状态，包含了所有的实现逻辑 apiserver: 可以理解为 etcd 的前置过滤器（理解为中心处理器，分发到各个连接的模块）
2.node(s) kubelet: 负责和 master 连接，注册 node, listen-watch 本 node 的任务等 kube-proxy: 用于 k8s service 对象。在 K8s 集群中微服务的负载均衡是由 Kube-proxy 实现的，它是 K8s 集群内部的负载均衡器，也是一个分布式代理服务器，在 K8s 的每个节点上都有一个，这一设计体现了它的伸缩性优势，需要访问服务的节点越多，提供负载均衡能力的 Kube-proxy 就越多，高可用节点也随之增多。 容器运行时: 除了 docker k8s 还支持 rkt 等容器实现
负责为 pod 提供代理。它会定期从 etcd 获取所有的 service，并根据 service 信息创建代理。</description>
    </item>
    
    <item>
      <title>k8s常见面试题</title>
      <link>/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/k8s/k8s%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/k8s/k8s%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>k8s常见面试题 如何在 Kubernetes 中实现负载均衡？ 在生产中，你如何实现 Kubernetes 自动化？ 你如何扩展 Kubernetes 集群？ 你能解释 Deployment、ReplicaSets、StatefulSets、Pod、CronJob 的不同用途吗？ Kubernetes 如何处理持久性？ 服务和 ingress 的作用是什么？ 你何时会使用像 ConfigMap 或 secret 这样的东西？ Pod 亲和性作用是什么？ 你能举例说明何时使用 Init Container 么？ 什么是 sidecar 容器？你能给出一个用例，说明你为什么要使用它么？ 在构建和管理生产集群时遇到的主要问题是什么？ 为什么你会建议公司在云中构建自己的 K8S 集群而不是使用托管服务？ 什么是 Istio 和 Linkerd？ 什么是 Kubernetes Operator？ kubernetes包含几个组件。 各个组件的功能是什么。组件之间是如何交互的。 k8s的pause容器有什么用。是否可以去掉。 k8s中的pod内几个容器之间的关系是什么。 一个经典pod的完整生命周期。 k8s的service和ep是如何关联和相互影响的。 详述kube-proxy原理, -个请求是如何经过层层转发落到某个pod.上的整个过程。请求可能来自pod也可能来自外部。 rc/rs功能是怎么实现的。详述从API接收到-一个创建rc/rs的请求,到最终在节点上创建pod的全过程,尽可能详细。另外,当-个pod失效时，kubernetes是如何发现并重启另一个pod的? deployment/rs有什么区别。 其使用方式使用条件和原理是什么。 cgroup中的cpu有哪几种限制方式。 k8s是如何使用实现request和limit的。</description>
    </item>
    
    <item>
      <title>k8s简介</title>
      <link>/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/k8s/k8s%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/k8s/k8s%E7%AE%80%E4%BB%8B/</guid>
      <description>一..k8s是什么，我们为啥要用 容器管理系统，提供部署，管理，扩展等机制，管理容器夸机器的应用 主要功能： 1.使用docker对应用包装，实例化，运行 2.以集群方式运行，管理跨机器的容器 3.解决docker跨机器容器之间的通讯问题 4.kubernetes的自我修复机制使得容器集群重视运行在用户期望的状态
为什么使用： 1.开发人员各司其职，轻装上整 2.全面拥抱微服务框架 3.使用kubernetes系统可以随时整体迁移 4.kubernetes系统具备超强的横向扩展功能
二，基本概念 1.功能组件 master apiserver：供 HTTP Rest 接口的关键服务程序，kubernets里所有资源增、删、改、查等操作的唯一入口，也是集群控制的入口进程 scheduler（调度）：资源调度(pod)的进程 controller-manager：负责管理各种控制，所有资源对象的自动化控制中心（资源对象的大总管） etcd：k-v数据库。所有资源对象全部保存在这里,支持服务与发现
node kebulet： pod对应容器的创建、暂停等任务 proxy：负责为pod提供代理。它会定期从etcd获取所有的service，并根据service信息创建代理。。k8s service 的通信与负载均衡机制的重要组件（主要对外支持的） docker：本机容器的管理与创建
2.操作对象 1.pod 最小部署单元，包含一个或多个容器，连接在一起的容器共享volue和网络，由kubernetes统一创建，调度，管理。可以直接创建，但是推荐使用rc 2.service pod的访问代理抽象 抽象服务出口，基础版本的负载均衡 3.replication controllers 管理pods的生命周期确保指定数量的pods会一直运行，实现资源收缩 一共4点
总体结构 1.master组件 apiserver： etcd：k-v数据库,系统的所有资源对象都保存在这里。支持服务注册与服务发现,微服务中常用的组件 scheduler（调度）：集群资源调度，分配pod的创建 controller-manager：管理rc，EndPointControl等各种控制器
2.node组件 kublet.负责管控docker容器,如，启动，停止等 proxy：负责为pod提供代理。定期从etcd获取service，并根据serveice创建代理
公共组件 etcd： flannel：网络协议</description>
    </item>
    
    <item>
      <title>Kafka常见面试题总结</title>
      <link>/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/kafka/kafka%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/kafka/kafka%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</guid>
      <description>Kafka 是什么？主要应用场景有哪些？ Kafka 是一个分布式流式处理平台。这到底是什么意思呢？
流平台具有三个关键功能：
消息队列：发布和订阅消息流，这个功能类似于消息队列，这也是 Kafka 也被归类为消息队列的原因。 容错的持久方式存储记录消息流： Kafka 会把消息持久化到磁盘，有效避免了消息丢失的风险。 流式处理平台： 在消息发布的时候进行处理，Kafka 提供了一个完整的流式处理类库。 Kafka 主要有两大应用场景：
消息队列 ：建立实时流数据管道，以可靠地在系统或应用程序之间获取数据。 数据处理： 构建实时的流数据处理程序来转换或处理数据流。 和其他消息队列相比,Kafka的优势在哪里？ 我们现在经常提到 Kafka 的时候就已经默认它是一个非常优秀的消息队列了，我们也会经常拿它跟 RocketMQ、RabbitMQ 对比。我觉得 Kafka 相比其他消息队列主要的优势如下：
极致的性能 ：基于 Scala 和 Java 语言开发，设计中大量使用了批量处理和异步的思想，最高可以每秒处理千万级别的消息。 生态系统兼容性无可匹敌 ：Kafka 与周边生态系统的兼容性是最好的没有之一，尤其在大数据和流计算领域。 实际上在早期的时候 Kafka 并不是一个合格的消息队列，早期的 Kafka 在消息队列领域就像是一个衣衫褴褛的孩子一样，功能不完备并且有一些小问题比如丢失消息、不保证消息可靠性等等。当然，这也和 LinkedIn 最早开发 Kafka 用于处理海量的日志有很大关系，哈哈哈，人家本来最开始就不是为了作为消息队列滴，谁知道后面误打误撞在消息队列领域占据了一席之地。
随着后续的发展，这些短板都被 Kafka 逐步修复完善。所以，Kafka 作为消息队列不可靠这个说法已经过时！
队列模型了解吗？Kafka 的消息模型知道吗？ 题外话：早期的 JMS 和 AMQP 属于消息服务领域权威组织所做的相关的标准，我在 JavaGuide的 《消息队列其实很简单》这篇文章中介绍过。但是，这些标准的进化跟不上消息队列的演进速度，这些标准实际上已经属于废弃状态。所以，可能存在的情况是：不同的消息队列都有自己的一套消息模型。
队列模型：早期的消息模型 使用队列（Queue）作为消息通信载体，满足生产者与消费者模式，一条消息只能被一个消费者使用，未被消费的消息在队列中保留直到被消费或超时。 比如：我们生产者发送 100 条消息的话，两个消费者来消费一般情况下两个消费者会按照消息发送的顺序各自消费一半（也就是你一个我一个的消费。）
队列模型存在的问题：
假如我们存在这样一种情况：我们需要将生产者产生的消息分发给多个消费者，并且每个消费者都能接收到完整的消息内容。
这种情况，队列模型就不好解决了。很多比较杠精的人就说：我们可以为每个消费者创建一个单独的队列，让生产者发送多份。这是一种非常愚蠢的做法，浪费资源不说，还违背了使用消息队列的目的。
发布-订阅模型:Kafka 消息模型 发布-订阅模型主要是为了解决队列模型存在的问题。</description>
    </item>
    
    <item>
      <title>linux命令</title>
      <link>/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/etcd/linux%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/etcd/linux%E5%91%BD%E4%BB%A4/</guid>
      <description>linux 命令 1.解压缩命令 解压 tar zxvf 文件名.tar.gz 压缩 tar zcvf 文件名.tar.gz 待压缩的文件名
2.从 linux 下载命令
scp /home/work/source.txt work@192.168.0.10:/home/work/ #把本地的 source.txt 文件拷贝到 192.168.0.10 机器上的/home/work 目录下
scp work@192.168.0.10:/home/work/source.txt /home/work/ #把 192.168.0.10 机器上的 source.txt 文件拷贝到本地的/home/work 目录下
scp work@192.168.0.10:/home/work/source.txt work@192.168.0.11:/home/work/ #把 192.168.0.10 机器上的 source.txt 文件拷贝到 192.168.0.11 机器的/home/work 目录下
scp -r /home/work/sourcedir work@192.168.0.10:/home/work/ #拷贝文件夹，加-r 参数
//下砸到本地 scp root@192.168.1.19:/home/server/go/serverb.tar.gz
scp root@192.168.1.19:/home/server/go/ssss.tar.gz
scp root@43.247.164.19:/home/server/go/ssss.tar.gzz /Users/mac/Desktop
3.复制文件 cp -i file1 file2 cp file1 file2
4.删除 &amp;ldquo;rm -f&amp;rdquo; 强行删除，忽略不存在的文件，不提示确认。(f 为 force 的意思) &amp;ldquo;rm -i&amp;rdquo; 进行交互式删除，即删除时会提示确认。(i 为 interactive 的意思) &amp;ldquo;rm -r&amp;rdquo; 将参数中列出的全部目录和子目录进行递归删除。(r 为 recursive 的意思) &amp;ldquo;rm -v&amp;rdquo; 详细显示删除操作进行的步骤。(v 为 verbose 的意思)</description>
    </item>
    
    <item>
      <title>参考文档</title>
      <link>/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/docker/%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/docker/%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3/</guid>
      <description>参考文档 docker中文 kubernetes kubernetes编排器 kubernetes中文文档 Portainer Portainer 轻量级的 Docker 管理 UI Portainer安装，设置等 docker可视化管理——Portainer安装教程 Docker安装 Mac平台上Docker安装与使用
mac安装docker图形界面
docker的etcd3的搭建</description>
    </item>
    
    <item>
      <title>参考文档</title>
      <link>/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/gin/%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/gin/%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3/</guid>
      <description>参考文档 全网最详细的gin源码解析 Gin框架介绍及使用&amp;ndash;李文周的博客 httprouter Gin框架中文文档 第三方库 tg验证库
学会gin参数校验之validator库，看这一篇就足够了
validator库参数校验若干实用技巧
Gin请求参数校验
Golang-Gin-API
例子 Golang Gin 实践 gin官方例子 GinLearn 参考 基础知识点 gin中文文档 Gin中文文档 源码 重要文档 GIN框架 Gin 框架中文文档 gin中文文档 使用 Gin web 框架的知名项目 </description>
    </item>
    
    <item>
      <title>插件</title>
      <link>/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/gin/%E6%8F%92%E4%BB%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/gin/%E6%8F%92%E4%BB%B6/</guid>
      <description> Gin实战技巧篇之云插件化开发 plugins-gin go-gin-api Gin-Gonic 中间件 限流中间件 </description>
    </item>
    
    <item>
      <title>Extra menu entries</title>
      <link>/content-organisation/extramenu/</link>
      <pubDate>Sat, 29 Apr 2017 18:36:24 +0200</pubDate>
      
      <guid>/content-organisation/extramenu/</guid>
      <description>You can define additional menu entries in the navigation menu without any link to content.
Edit the website configuration config.toml and add a [[menu.shortcuts]] entry for each link your want to add.
Example from the current website, note the pre param which allows you to insert HTML code and used here to separate content&amp;rsquo;s menu from this &amp;ldquo;static&amp;rdquo; menu
[[menu.shortcuts]]pre = &amp;quot;&amp;lt;h3&amp;gt;More&amp;lt;/h3&amp;gt;&amp;quot;name = &amp;quot;&amp;lt;i class=&#39;fa fa-github&#39;&amp;gt;&amp;lt;/i&amp;gt; Github repo&amp;quot;identifier = &amp;quot;ds&amp;quot;url = &amp;quot;https://github.</description>
    </item>
    
    <item>
      <title>Configuration</title>
      <link>/getting-start/configuration/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/getting-start/configuration/</guid>
      <description>&lt;p&gt;When building the website, you can set a theme by using &lt;code&gt;--theme&lt;/code&gt; option. We suggest you to edit your configuration file and set the theme by default. Example with &lt;code&gt;config.toml&lt;/code&gt; format.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>ants</title>
      <link>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/program_analy/ants/</link>
      <pubDate>Tue, 17 Oct 2017 15:26:15 +0000</pubDate>
      
      <guid>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/program_analy/ants/</guid>
      <description>#ants ##地址:https://github.com/panjf2000/ants https://github.com/panjf2000
📖 简介 高性能的 goroutine 池 ##文件
文件 描述 说明 ants.go 主结构 主要是配置 pool.go 工作池结构 工作主入口，管理池 pool_func.go 带函数池 管理带函数的池子 worker_func.go 带函数工作接口 管理带函数的工作 worker_array.go 工作组接口 创建方式为栈或队列，返回的是接口 worker.go 工作接口 处理工作函数 worker_stack.go 工作栈 栈的实现方式，使用的二分法 worker_loop_queue.go 工作池队列 队列方式实现 ##经验 1.sync 包的使用 2.goroutine 池的管理和设计(带函数和不带函数)
#技术包 ##技术包 ###技术包 #####技术包 ######技术包 #######技术包
技术包
但是发 发发发撒发
阿但是发撒都发撒啊阿啊
第一项 第二项 第三项 sdfa sdfa sdfa sdfa sdfa dfsaa asdf
dsfasdafsdfasdfadsaffadfsfaasdffasfdafsadfhttps://www.runoob.com 表头 表头 都发撒 单元格 单元格 sdffas 单元格 都发撒发撒 sdfsafas graph LRA[方形] --&amp;gt;B(圆角)B --&amp;gt; C{条件a}C --&amp;gt;|a=1| D[结果1]C --&amp;gt;|a=2| E[结果2]F[横向流程图] Title: 标题：复杂使用对象A-&amp;gt;对象B: 对象B你好吗?</description>
    </item>
    
    <item>
      <title>bytebufferpool</title>
      <link>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/program_analy/bytebufferpool/</link>
      <pubDate>Tue, 17 Oct 2017 15:26:15 +0000</pubDate>
      
      <guid>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/program_analy/bytebufferpool/</guid>
      <description>#ants ##地址:https://github.com/valyala/bytebufferpool
📖 简介 字节缓冲池
文件 描述 说明 bytebuffer.go 字节缓存 字符串，IO，数组等的写入缓存 pool.go 缓存管理 缓存空间管理 ##文件
##经验 1.切片的使用 2.sync.Pool使用</description>
    </item>
    
    <item>
      <title>gev</title>
      <link>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/program_analy/gev/</link>
      <pubDate>Tue, 17 Oct 2017 15:26:15 +0000</pubDate>
      
      <guid>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/program_analy/gev/</guid>
      <description>gev 地址:https://github.com/Allenxuxu/gev.git Go 网络库并发对比 https://blog.csdn.net/meiyoudao_jiushidao/article/details/102657231</description>
    </item>
    
    <item>
      <title>gnet</title>
      <link>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/program_analy/gnet/</link>
      <pubDate>Tue, 17 Oct 2017 15:26:15 +0000</pubDate>
      
      <guid>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/program_analy/gnet/</guid>
      <description>gnet 地址:https://github.com/panjf2000/gnet 📖 简介 字节缓冲池
文件 描述 说明 ringbuffer 循环缓冲 构造循环缓冲基本 pool 线程池 缓存池的使用 internal 内部 缓存空间管理 acceptor 接收 接受连接 codec 编解码 编解码 connection 连接 网络连接 errors.go 错误处理 eventloop_group 事件循环组 gnet.go 主结构 listener 监听 loop 循环事件 reactor server 服务 网络服务器 文件 经验 1.循环池的设计使用 2.sync.Pool 使用</description>
    </item>
    
    <item>
      <title>hexo</title>
      <link>/%E5%B7%A5%E5%85%B7/hexo/hexo/</link>
      <pubDate>Tue, 17 Oct 2017 15:26:15 +0000</pubDate>
      
      <guid>/%E5%B7%A5%E5%85%B7/hexo/hexo/</guid>
      <description>Hexo 官网文档</description>
    </item>
    
    <item>
      <title>hexo安装</title>
      <link>/%E5%B7%A5%E5%85%B7/hexo/hexo%E5%AE%89%E8%A3%85/</link>
      <pubDate>Tue, 17 Oct 2017 15:26:15 +0000</pubDate>
      
      <guid>/%E5%B7%A5%E5%85%B7/hexo/hexo%E5%AE%89%E8%A3%85/</guid>
      <description>安装 1.Node.js 官网
验证 node -v npm -v
2.Git 官网
tips：Git Bash 相当于Linux中的终端窗口
验证 git version
3.hexo npm install -g hexo-cli 验证 hexo -v 4.创建案例 hexo init blog cd blog npm install
5.运行测试 hexo clean #用来清理缓存文件 hexo g #生成文件 hexo s #运行本地服务器 hexo d #上传到服务器
运行 hexo g hexo s
打开网站 localhost:4000</description>
    </item>
    
    <item>
      <title>hugo</title>
      <link>/%E5%B7%A5%E5%85%B7/hugo/hugo/</link>
      <pubDate>Tue, 17 Oct 2017 15:26:15 +0000</pubDate>
      
      <guid>/%E5%B7%A5%E5%85%B7/hugo/hugo/</guid>
      <description>官网 下载 主题 1.安装 1.解压 2.添加到环境变量 3.验证 hugo version 2.新建站点 hugo new site myblog 3.下载主题 git到theme文件夹 启动 hugo server -t hugo-theme-techdoc http://localhost:1313 hugo server -t hugo-theme-techdoc 4.修改配置 发布 hugo</description>
    </item>
    
    <item>
      <title>关键字</title>
      <link>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/third/%E7%BB%93%E6%9E%84%E4%BD%93%E6%A0%87%E7%AD%BE/%E5%85%B3%E9%94%AE%E5%AD%97/</link>
      <pubDate>Tue, 17 Oct 2017 15:26:15 +0000</pubDate>
      
      <guid>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/third/%E7%BB%93%E6%9E%84%E4%BD%93%E6%A0%87%E7%AD%BE/%E5%85%B3%E9%94%AE%E5%AD%97/</guid>
      <description>#json
json: &amp;quot;-&amp;quot; // 表示不进行序列化，该字段总是在序列化被省略。 json: &amp;quot;xxx,omitempty&amp;quot; //表示如果字段具有空值则该字段应从编码中省略
go中json序列化使用标签来进行拓展： 1、忽略空值： type Person struct { Id int64 json:&amp;quot;id, omitempty&amp;quot; }
2、忽略字段（不论是否为空值）： type Person struct { Id int64 json:&amp;quot;-&amp;quot; }
3、指定数据类型： type Person struct { Id int64 json:&amp;quot;id,string&amp;quot; }
#xml
#Protobuf</description>
    </item>
    
    <item>
      <title>部署到git</title>
      <link>/%E5%B7%A5%E5%85%B7/hexo/hexo%E9%83%A8%E7%BD%B2%E5%88%B0git/</link>
      <pubDate>Tue, 17 Oct 2017 15:26:15 +0000</pubDate>
      
      <guid>/%E5%B7%A5%E5%85%B7/hexo/hexo%E9%83%A8%E7%BD%B2%E5%88%B0git/</guid>
      <description>部署到git 1.安装 hexo-deployer-git npm install hexo-deployer-git --save 验证 npm list hexo-deployer-git
2.修改配置 deploy: type: git repo: https://github.com/mengfeirun/mengfeirun.github.io.git branch: [branch] message: [message] </description>
    </item>
    
    <item>
      <title>mysql重点</title>
      <link>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E9%87%8D%E7%82%B9/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E9%87%8D%E7%82%B9/</guid>
      <description>设计优化 一,设计
数据库统计 1.时间换空间(分时统计) 一定时间统计一次(统计到别的数据库,进行查询) 2.处理死数据和激活数据
二，索引优化
三.锁优化 表级锁 行级锁 页面锁
四 查询优化 减少 IO 减少网络</description>
    </item>
    
    <item>
      <title>mysql面试题</title>
      <link>/%E6%95%B0%E6%8D%AE%E5%BA%93/mongo/%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/%E6%95%B0%E6%8D%AE%E5%BA%93/mongo/%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>MongoDB高频面试题 1）解释什么是MongoDB？ 2）什么是MongoDB中的“命名空间”？ 3）MongoDB中的分片是什么？ 4）查看Mongos使用的连接？ 5）解释什么是副本集？ 6）复制在MongoDB中如何工作？ 7）在MongoDB中创建模式时，需要考虑哪些要点？ 8）在MongoDB中创建集合并将其删除的语法是什么？ 9）说明Profiler在MongoDB中的作用是什么？ 10）解释一下您可以将旧文件移动到moveChunk目录中吗？ 11）要进行安全备份，可以使用MongoDB中的功能是什么？ 12）提及Objecld由什么组成？ 13）提及插入文档的命令语法是什么？ 14）提到如何检查函数的源代码？ 15）查看是否在主服务器上的命令语法是什么？MongoDB允许多少个主机？ 16）提到用于查看Mongo的命令语法正在使用链接吗？ 17）解释一下MongoDB中的索引是什么？ 18）提到在MongoDB中使用索引的基本语法是什么？ 19）解释什么是MongoDB中的GridFS？ 20）MongoDB相似的产品有哪些？ Cassandra，CouchDB，Redis，Riak，Hbase等。</description>
    </item>
    
    <item>
      <title>mysql面试题</title>
      <link>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>1.事务 原子性 隔离性 一直性 持久性
2.MyISAM和InnoDB区别 MyISAM不支持外键和事务，innodb支持 MyISAM锁的粒度是表级，而InnoDB支持行级锁定 MyISAM支持全文类型索引，而InnoDB不支持全文索引。 MyISAM相对简单，所以在效率上要优于InnoDB，小型应用可以考虑使用MyISAM MyISAM创建表生成三个文件：.frm数据表结构 .myd数据文件 .myi索引文件，Innodb只生成一个frm文件，数据存放在ibdata1.log MyISAM使用delete语句删除后并不会立刻清理磁盘空间，需要定时清理，命令：OPTIMIZE table dept;
3.delete drop truncate区别 truncate 和 delete只删除数据，不删除表结构 ,drop删除表结构，并且释放所占的空间。 删除数据的速度，一般来说: drop&amp;gt; truncate &amp;gt; delete delete属于DML语言，需要事务管理，commit之后才能生效。drop和truncate属于DDL语言，操作立刻生效，不可回滚 使用场合： 当你不再需要该表时， 用 drop; 当你仍要保留该表，但要删除所有记录时， 用 truncate; 当你要删除部分记录时（always with a where clause), 用 delete. 注意： 对于有主外键关系的表，不能使用truncate而应该使用不带where子句的delete语句，由于truncate不记录在日志中，不能够激活触发器
4.索引 MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。 InnoDB也使用B+Tree作为索引结构。InnoDB的数据文件本身就是索引文件。
索引种类 主键索引（把某列设为主键，则该列就是索引，主键不能重复） 唯一索引（unique），该列具有唯一性，同时又是索引 index 普通索引 全文索引 （fulltext） 只有MyISAM存储引擎支持 （注：mysql 5.6之后，Innodb也开始支持全文索引，mysql5.6较之前版本有较大更新，有兴趣的小伙伴可以去查一查）
5.适合加索引的列： 经常查询的列上加索引 唯一性太差的列不要加索引（重复太多），相反唯一性比较好的列适合加索引 不经常修改的列适合加。经常修改的列不要加索引（列修改，索引也要改） 因为索引的创建和更改是有开销的。
6.mysql优化 1.数据表的优化（符合3范式） 1.1范式：1NF是对属性的原子性约束，要求属性具有原子性，不可再分解；(只要是关系型数据库都满足1NF)2.2范式：2NF是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性；3.3范式：3NF是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余。没有冗余的数据库设计可以做到4.但是，没有冗余的数据库未必是最好的数据库，有时为了提高运行效率，就必须降低范式标准，适当保留冗余数据。具体做法是：在概念数据模型设计时遵守第三范式，降低范式标准的工作放到物理数据模型设计时考虑。降低范式就是增加字段，允许冗余。2.sql语句优化 索引 3.</description>
    </item>
    
    <item>
      <title>参考文档</title>
      <link>/%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch/%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch/%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3/</guid>
      <description>网站 官网 Elasticsearch中文文档 Elasticsearch中文社区 ElasticSearch使用场景 Elasticsearch入门指南 Elasticsearch+logstash+kibana实现日志分析（实验） Elasticsearch 思维导图集锦 日志系统 从零学Elasticsearch系列——搭建ELK Nginx日志分析平台 Elasticsearch+logstash+kibana实现日志分析（实验） docker-compose一键部署elasticsearch+logstash+kibana ELK日志系统：Elasticsearch + Logstash + Kibana 搭建教程 ElasticSearch使用场景 用Kibana和logstash快速搭建实时日志查询、收集与分析系统 如何快速搭建一个简易的ELK日志分析系统 快速搭建ELK日志分析系统 快速搭建一套elk日志系统 </description>
    </item>
    
    <item>
      <title>参考文档</title>
      <link>/%E6%95%B0%E6%8D%AE%E5%BA%93/mongo/%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/%E6%95%B0%E6%8D%AE%E5%BA%93/mongo/%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3/</guid>
      <description>MongoDB中文手册|官方文档中文版
MongoDB
mongodb学习笔记
MongoDB(思维导图)
思维导图学《Mongo 官方文档》
MongoDB初学知识思维导图
Mongodb思维导图
面试挂在数据库？莫慌，我赠你全套笔记（MySQL+redis+MongoDB）
Mongodb思维导图
MongoDB 教程
mongodb学习总结
MongoDB架构学习笔记
mongodb中文文档
mongodb中文手册
面试文档 95道MongoDB面试题（含答案），1万字详细解析 快2020年了，赶紧收藏起MongoDB面试题轻松面对BAT灵魂式的拷问 MongoDB高频面试题 28个MongoDB经典面试题 MongoDB面试题和答案全集解析 MongoDB面试题问题以及参考答案 #MongoDB相似的产品有哪些？ Cassandra，CouchDB，Redis，Riak，Hbase等。</description>
    </item>
    
    <item>
      <title>参考资料</title>
      <link>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/</guid>
      <description>#mysql 是关系型数据库 mysql总结(一)：思维导图
mysql总结 高性能MySQL系统思维导图 MySql之增删改查总结 MySQL存储过程
#面试资料 MySQL 面试之必会知识点 史上最详细的一线大厂Mysql面试题详解 Mysql面试知识点总结(进阶篇) MySQL 分库分表方案，总结的非常好！ 干货！MySql DAL中间件总结
#数据库优化 万字总结：学习MySQL优化原理，这一篇就够了！ 记录一次MySQL两千万数据的大表优化解决过程，提供三种解决方案 史上最详细的一线大厂Mysql面试题详解 MySQL 的优化方案总结</description>
    </item>
    
    <item>
      <title>参考资料</title>
      <link>/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/</guid>
      <description> Redis思维导图
Redis命令参考
Redis中文站
Redis中文
Redis教程
Redis5.0数据淘汰策略详解（最新版本，面试常问）
Redis 教程
通过思维导图整理redis的重要知识点
Redis思维导图
redis知识点最详细的总结，&amp;ndash;数据类型，相关配置
一个能看懂的Redis思维导图
Redis校招面经知识整理 133条目！很全！（xmind思维导图格式，便于记忆和理解）下载
Redis思维导图
Redis学习笔记
redis知识点总结
缓存 缓存穿透、缓存击穿、缓存雪崩区别和解决方案
应对缓存击穿的解决方法
帮你解读什么是Redis缓存穿透和缓存雪崩(包含解决方案)
Redis知识点本文就够 降低redis内存使用与减少请求延迟
面试题 Redis面试题(2020最新版) Redis常见面试题 50道Redis面试题及答案整理，史上最全！ 史上最全Redis面试题及答案 Redis面试题和答案完全解读 史上最全redis面试题及答案吊打面试官 应用场景 Redis 的 8 大应用场景！ Redis常见的应用场景解析 Redis应用场景 redis应用场景及实例 Redis的7个应用场景 redis文档 Redis 命令参考 思维导图学 Redis —— 《Redis设计与实现》 #Redis# 利用思维导图整理的redis重要知识点 Redis好资料 Redis 设计与实现 </description>
    </item>
    
    <item>
      <title>数据结构</title>
      <link>/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      <description>k-v
存储键和五种不同类型的值之间的映射。键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。
与传统数据库不同的是 Redis 的数据是存在内存中的，所以读写速度非常快，因此 redis 被广泛应用于缓存方向，每秒可以处理超过 10 万次读写操作，是已知性能最快的 Key-Value DB。另外，Redis 也经常用来做分布式锁。除此之外，Redis 支持事务 、持久化、LUA 脚本、LRU 驱动事件、多种集群方案。
速度快（ Redis 能读的速度是 110000 次/s，写的速度是 81000 次/s。） 内存中 分布式锁 持久化（AOF,RDB） lua 脚本 事务(所有都是原子性) LRU 驱动事件 集群（主从）（读写分离）（在线扩容）
高性能，高并发
实际例子（排行，统计例子）
应用场景： 1.计数 2.排名 3.统计访问次数 4.缓存 5.会话缓存 6.查找缓存 7.分布式锁
持久化： AOF：记录每次对服务器写的操作 RDB：指定的时间间隔能对你的数据进行快照存储</description>
    </item>
    
    <item>
      <title>面试问答</title>
      <link>/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E9%9D%A2%E8%AF%95%E9%97%AE%E7%AD%94/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E9%9D%A2%E8%AF%95%E9%97%AE%E7%AD%94/</guid>
      <description>Redis支持的数据类型？ 1、Redis基本数据结构 2、Redis的List用过吗？底层怎么实现的？知道但是没用过，不知道怎么实现 3、redis排行榜数据结构（跳跃表），查询时间复杂度 4、redis分布式，如何减少同步延迟
９８、redis的数据类型
１２４、redis容灾，备份，扩容
什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什么？
刚刚上面你有提到redis通讯协议(RESP )，能解释下什么是RESP？有什么特点？（可以看到很多面试其实都是连环炮，面试官其实在等着你回答到这个点，如果你答上了对你的评价就又加了一分）
Redis 有哪些架构模式？讲讲各自的特点
什么是一致性哈希算法？什么是哈希槽？ Redis常用命令？ 使用过Redis分布式锁么，它是怎么实现的？ 使用过Redis做异步队列么，你是怎么用的？有什么缺点？ 什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？
redis 问答 1、什么是Redis？ 2、Redis有哪些数据结构？ 3、Redis相比memcached有哪些优势？ 4、Redis有哪些适合的场景？ 5、Redis有哪几种数据淘汰策略？ 6、使用过Redis分布式锁么，它是什么回事？ 7、假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？ 8、由7接着问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？ 9、如果有大量的key需要设置同一时间过期，一般需要注意什么？ 10、如何处理redis集群中big key和hot key？ 11、MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？ 12、使用过Redis做异步队列么，你是怎么用的？ 13、如果对方追问redis如何实现延时队列？ 14、说说Redis哈希槽的概念？ 15、Redis中的Pipeline有什么好处，为什么要用pipeline？ 16、Redis与其他key-value存储有什么不同？ 17、Redis和Redisson有什么关系？ 18、Jedis与Redisson对比有什么优缺点？ 19、支持一致性哈希的客户端有哪些？ 20、Twemproxy是什么？ 21、怎么理解Redis事务？ 22、Redis回收进程如何工作的？ 23、Redis回收使用的是什么算法？ 24、Redis如何做大量数据插入？ 25、为什么要做Redis分区？ 26、你知道有哪些Redis分区实现方案？ 27、Redis分区有什么缺点？ 28、为什么Redis需要把所有数据放到内存中？ 29、Redis的内存占用情况怎么样？ 30、都有哪些办法可以降低Redis的内存使用情况呢？ 31、Redis的内存用完了会发生什么？ 32、Redis如何做内存优化？ 33、Redis如何做持久化的？ 34、对方追问bgsave的原理是什么？ 35、Redis提供了哪几种持久化方式？ 36、如何选择合适的持久化方式？ 37、Redis是单线程的，如何提高多核CPU的利用率？ 38、Redis常见性能问题和解决方案？ 39、修改配置不重启Redis会实时生效吗？ 40、Redis的同步机制了解么？ 41、是否使用过Redis集群，集群的原理是什么？ 42、Redis集群方案应该怎么做？都有哪些方案？ 43、Redis集群方案什么情况下会导致整个集群不可用？ 44、Redis集群的主从复制模型是怎样的？ 44、Redis的集群方案之间都有哪些区别，其优点和缺点是什么？ 45、Redis集群会有写操作丢失吗？为什么？ 46、Redis集群之间是如何复制的？ 47、Redis集群最大节点个数是多少？ 48、一个Redis实例最多能存放多少的keys？List、Set、Sorted Set他们最多能存放多少元素？ 49、Redis持久化数据和缓存怎么做扩容？ 50、分布式Redis是前期做还是后期规模上来了再做好？为什么？</description>
    </item>
    
    <item>
      <title>Home page</title>
      <link>/create-page/homepage/</link>
      <pubDate>Fri, 28 Apr 2017 18:36:24 +0200</pubDate>
      
      <guid>/create-page/homepage/</guid>
      <description>To tell Hugo-theme-docdock to consider a page as homepage&amp;rsquo;s content, just create a content file named _index.md in content folder.</description>
    </item>
    
    <item>
      <title>About images</title>
      <link>/create-page/page-images/</link>
      <pubDate>Mon, 24 Apr 2017 18:36:24 +0200</pubDate>
      
      <guid>/create-page/page-images/</guid>
      <description>Images have a similar syntax to links but include a preceding exclamation point.
![agence](https://github.com/vjeantet/vjeantet.fr/raw/master/static/images/sgthon/C.jpg)Resizing image Add HTTP parameters width and/or height to the link image to resize the image. Values are CSS values (default is auto).
![Hackathon](https://github.com/vjeantet/vjeantet.fr/raw/master/static/images/sgthon/C.jpg?height=80px)Add CSS classes Add a HTTP classes parameter to the link image to add CSS classes. shadow and border are available but you could define other ones.
![s](https://github.com/vjeantet/vjeantet.fr/raw/master/static/images/sgthon/C.jpg?classes=border,shadow)</description>
    </item>
    
    <item>
      <title>My Slide ! fullscreen</title>
      <link>/create-page/myslide/</link>
      <pubDate>Mon, 24 Apr 2017 18:36:24 +0200</pubDate>
      
      <guid>/create-page/myslide/</guid>
      <description>In the morning Getting up Turn off alarm Get out of bed Breakfast Eat eggs Drink coffee In the evening Dinner Eat spaghetti Drink wine Going to sleep Get in bed Count sheep </description>
    </item>
    
    <item>
      <title>Present a Slide</title>
      <link>/create-page/page-slide/</link>
      <pubDate>Mon, 24 Apr 2017 18:36:24 +0200</pubDate>
      
      <guid>/create-page/page-slide/</guid>
      <description>A basic md content page can be rendered as a reveal.js presentation full screen.
You can, also, embed presentation in a page as a small box, using the revealjs shortcode in your md file.Formating Use your common Markdown syntax you use in Hugo, don&amp;rsquo;t forget, you can put html tags too.
Special syntax (in html comment) is available for adding attributes to Markdown elements. This is useful for fragments, amongst other things.</description>
    </item>
    
    <item>
      <title></title>
      <link>/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/docker/%E8%B5%84%E6%96%99/dockermssql/create_qpsqldbbase/%E8%AF%B4%E6%98%8E/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/docker/%E8%B5%84%E6%96%99/dockermssql/create_qpsqldbbase/%E8%AF%B4%E6%98%8E/</guid>
      <description>Docker for Windows 使用 VMware WorkStation
登录dev实例 docker-machine ssh dev
查看容器 docker ps
创建快照 docker commit -p e5a5689d08ac qpsqldbbase-backup
查看镜像 docker images
保存镜像 docker save -o qpsqldbbase-backup.tar qpsqldbbase-backup
恢复镜像 docker load -i qpsqldbbase-backup.tar
netstat -aon|findstr &amp;ldquo;2048&amp;rdquo;
$ docker ps // 查看所有正在运行容器 $ docker stop containerId // containerId 是容器的ID
$ docker ps -a // 查看所有容器 $ docker ps -a -q // 查看所有容器ID
$ docker stop $(docker ps -a -q) // stop停止所有容器 $ docker rm $(docker ps -a -q) // remove删除所有容器</description>
    </item>
    
    <item>
      <title></title>
      <link>/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/docker/%E8%B5%84%E6%96%99/docker%E7%9A%84etcd3%E7%9A%84%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/docker/%E8%B5%84%E6%96%99/docker%E7%9A%84etcd3%E7%9A%84%E6%90%AD%E5%BB%BA/</guid>
      <description>docker的etcd3的搭建</description>
    </item>
    
    <item>
      <title></title>
      <link>/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/k8s/%E5%85%B6%E4%BB%96%E6%8A%80%E6%9C%AF/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/k8s/%E5%85%B6%E4%BB%96%E6%8A%80%E6%9C%AF/</guid>
      <description>服务与发现技术 etcd:注册发现 内部有事务和监听机制 分组 zookeeper consul eureka</description>
    </item>
    
    <item>
      <title></title>
      <link>/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/k8s/%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/k8s/%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3/</guid>
      <description>#文档参考 Kubernetes中文社区 | 中文文档 十分钟带你理解Kubernetes核心概念 k8s资料 Kubernetes 介绍
#思维导图 k8s思维导图 男孩周末班-k8s-思维导图</description>
    </item>
    
    <item>
      <title></title>
      <link>/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/k8s/%E5%8F%91%E5%B8%83%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/k8s/%E5%8F%91%E5%B8%83%E6%9C%8D%E5%8A%A1/</guid>
      <description>kubernetes核心组件kube-proxy - 运维笔记
在 K8s 集群中微服务的负载均衡是由 Kube-proxy 实现的，它是 K8s 集群内部的负载均衡器，也是一个分布式代理服务器，在 K8s 的每个节点上都有一个，这一设计体现了它的伸缩性优势，需要访问服务的节点越多，提供负载均衡能力的 Kube-proxy 就越多，高可用节点也随之增多。</description>
    </item>
    
    <item>
      <title></title>
      <link>/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/k8s/%E7%94%A8%E9%80%94/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/k8s/%E7%94%A8%E9%80%94/</guid>
      <description>1.你能解释 Deployment、ReplicaSets、StatefulSets、Pod、CronJob 的不同用途吗？ Deployment:开发更新 ReplicaSets:集合控制 StatefulSets:状态集合 Pod:虚拟的实体 CronJob:运行自动化 2.Kubernetes 如何处理持久性？ 服务和 ingress 的作用是什么？ 你何时会使用像 ConfigMap 或 secret 这样的东西？ Pod 亲和性作用是什么？ 你能举例说明何时使用 Init Container 么？ 什么是 sidecar 容器？你能给出一个用例，说明你为什么要使用它么？
https://jimmysong.io/kubernetes-handbook/practice/service-discovery-and-loadbalancing.html</description>
    </item>
    
    <item>
      <title></title>
      <link>/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/kafka/kafaka%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/kafka/kafaka%E7%AE%80%E4%BB%8B/</guid>
      <description>https://github.com/Snailclimb/JavaGuide/blob/master/docs/system-design/data-communication/Kafka%E5%85%A5%E9%97%A8%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86.md
Kafka 简介 Kafka 是一种分布式的，基于发布 / 订阅的消息系统。
主要设计目标如下：
以时间复杂度为 O(1) 的方式提供消息持久化能力，即使对 TB 级以上数据也能保证常数时间复杂度的访问性能。 高吞吐率。即使在非常廉价的商用机器上也能做到单机支持每秒 100K 条以上消息的传输。 支持 Kafka Server 间的消息分区，及分布式消费，同时保证每个 Partition 内的消息顺序传输。 同时支持离线数据处理和实时数据处理。 Scale out：支持在线水平扩展。
Kafka 基础概念 概念一：生产者与消费者 对于 Kafka 来说客户端有两种基本类型：
生产者（Producer） 消费者（Consumer）。 除此之外，还有用来做数据集成的 Kafka Connect API 和流式处理的 Kafka Streams 等高阶客户端，但这些高阶客户端底层仍然是生产者和消费者API，它们只不过是在上层做了封装。
这很容易理解，生产者（也称为发布者）创建消息，而消费者（也称为订阅者）负责消费or读取消息。
概念二：主题（Topic）与分区（Partition）
在 Kafka 中，消息以**主题（Topic）**来分类，每一个主题都对应一个 「消息队列」，这有点儿类似于数据库中的表。但是如果我们把所有同类的消息都塞入到一个“中心”队列中，势必缺少可伸缩性，无论是生产者/消费者数目的增加，还是消息数量的增加，都可能耗尽系统的性能或存储。
我们使用一个生活中的例子来说明：现在 A 城市生产的某商品需要运输到 B 城市，走的是公路，那么单通道的高速公路不论是在「A 城市商品增多」还是「现在 C 城市也要往 B 城市运输东西」这样的情况下都会出现「吞吐量不足」的问题。所以我们现在引入**分区（Partition）**的概念，类似“允许多修几条道”的方式对我们的主题完成了水平扩展。
概念三：Broker 和集群（Cluster） 一个 Kafka 服务器也称为 Broker，它接受生产者发送的消息并存入磁盘；Broker 同时服务消费者拉取分区消息的请求，返回目前已经提交的消息。使用特定的机器硬件，一个 Broker 每秒可以处理成千上万的分区和百万量级的消息。（现在动不动就百万量级..我特地去查了一把，好像确实集群的情况下吞吐量挺高的..嗯..）
若干个 Broker 组成一个集群（Cluster），其中集群内某个 Broker 会成为集群控制器（Cluster Controller），它负责管理集群，包括分配分区到 Broker、监控 Broker 故障等。在集群内，一个分区由一个 Broker 负责，这个 Broker 也称为这个分区的 Leader；当然一个分区可以被复制到多个 Broker 上来实现冗余，这样当存在 Broker 故障时可以将其分区重新分配到其他 Broker 来负责。下图是一个样例：</description>
    </item>
    
    <item>
      <title></title>
      <link>/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/kafka/kafka/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/kafka/kafka/</guid>
      <description>Kafka是最初由Linkedin公司开发，是一个分布式、分区的、多副本的、多订阅者，基于zookeeper协调的分布式日志系统（也可以当做MQ系统），常见可以用于web/nginx日志、访问日志，消息服务等等，Linkedin于2010年贡献给了Apache基金会并成为顶级开源项目。
主要应用场景是：日志收集系统和消息系统。
Kafka主要设计目标如下：
以时间复杂度为O(1)的方式提供消息持久化能力，即使对TB级以上数据也能保证常数时间的访问性能。 高吞吐率。即使在非常廉价的商用机器上也能做到单机支持每秒100K条消息的传输。 支持Kafka Server间的消息分区，及分布式消费，同时保证每个partition内的消息顺序传输。 同时支持离线数据处理和实时数据处理。 Scale out:支持在线水平扩展
1.2　消息系统介绍 一个消息系统负责将数据从一个应用传递到另外一个应用，应用只需关注于数据，无需关注数据在两个或多个应用间是如何传递的。分布式消息传递基于可靠的消息队列，在客户端应用和消息系统之间异步传递消息。有两种主要的消息传递模式：点对点传递模式、发布-订阅模式。大部分的消息系统选用发布-订阅模式。Kafka就是一种发布-订阅模式。
1.3　点对点消息传递模式（ 生产消费模式,消费一次） 在点对点消息系统中，消息持久化到一个队列中。此时，将有一个或多个消费者消费队列中的数据。但是一条消息只能被消费一次。当一个消费者消费了队列中的某条数据之后，该条数据则从消息队列中删除。该模式即使有多个消费者同时消费数据，也能保证数据处理的顺序。这种架构描述示意图如下：
1.4　发布-订阅消息传递模式 在发布-订阅消息系统中，消息被持久化到一个topic中。与点对点消息系统不同的是，消费者可以订阅一个或多个topic，消费者可以消费该topic中所有的数据，同一条数据可以被多个消费者消费，数据被消费后不会立马删除。在发布-订阅消息系统中，消息的生产者称为发布者，消费者称为订阅者。该模式的示例图如下：
二、Kafka的优点 2.1　解耦 在项目启动之初来预测将来项目会碰到什么需求，是极其困难的。消息系统在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口。这允许你独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。
2.2　冗余（副本） 有些情况下，处理数据的过程会失败。除非数据被持久化，否则将造成丢失。消息队列把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。许多消息队列所采用的&amp;quot;插入-获取-删除&amp;quot;范式中，在把一个消息从队列中删除之前，需要你的处理系统明确的指出该消息已经被处理完毕，从而确保你的数据被安全的保存直到你使用完毕。
2.3　扩展性 因为消息队列解耦了你的处理过程，所以增大消息入队和处理的频率是很容易的，只要另外增加处理过程即可。不需要改变代码、不需要调节参数。扩展就像调大电力按钮一样简单。
2.4　灵活性&amp;amp;峰值处理能力 在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见；如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。
2.5　可恢复性 系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。
2.6　顺序保证 在大多使用场景下，数据处理的顺序都很重要。大部分消息队列本来就是排序的，并且能保证数据会按照特定的顺序来处理。Kafka保证一个Partition内的消息的有序性。
2.7　缓冲 在任何重要的系统中，都会有需要不同的处理时间的元素。例如，加载一张图片比应用过滤器花费更少的时间。消息队列通过一个缓冲层来帮助任务最高效率的执行———写入队列的处理会尽可能的快速。该缓冲有助于控制和优化数据流经过系统的速度。
2.8　异步通信 很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。
三、常用Message Queue对比 3.1　RabbitMQ RabbitMQ是使用Erlang编写的一个开源的消息队列，本身支持很多的协议：AMQP，XMPP, SMTP, STOMP，也正因如此，它非常重量级，更适合于企业级的开发。同时实现了Broker构架，这意味着消息在发送给客户端时先在中心队列排队。对路由，负载均衡或者数据持久化都有很好的支持。
3.2　Redis Redis是一个基于Key-Value对的NoSQL数据库，开发维护很活跃。虽然它是一个Key-Value数据库存储系统，但它本身支持MQ功能，所以完全可以当做一个轻量级的队列服务来使用。对于RabbitMQ和Redis的入队和出队操作，各执行100万次，每10万次记录一次执行时间。测试数据分为128Bytes、512Bytes、1K和10K四个不同大小的数据。实验表明：入队时，当数据比较小时Redis的性能要高于RabbitMQ，而如果数据大小超过了10K，Redis则慢的无法忍受；出队时，无论数据大小，Redis都表现出非常好的性能，而RabbitMQ的出队性能则远低于Redis。
3.3　ZeroMQ ZeroMQ号称最快的消息队列系统，尤其针对大吞吐量的需求场景。ZeroMQ能够实现RabbitMQ不擅长的高级/复杂的队列，但是开发人员需要自己组合多种技术框架，技术上的复杂度是对这MQ能够应用成功的挑战。ZeroMQ具有一个独特的非中间件的模式，你不需要安装和运行一个消息服务器或中间件，因为你的应用程序将扮演这个服务器角色。你只需要简单的引用ZeroMQ程序库，可以使用NuGet安装，然后你就可以愉快的在应用程序之间发送消息了。但是ZeroMQ仅提供非持久性的队列，也就是说如果宕机，数据将会丢失。其中，Twitter的Storm 0.9.0以前的版本中默认使用ZeroMQ作为数据流的传输（Storm从0.9版本开始同时支持ZeroMQ和Netty作为传输模块）。
3.4　ActiveMQ ActiveMQ是Apache下的一个子项目。 类似于ZeroMQ，它能够以代理人和点对点的技术实现队列。同时类似于RabbitMQ，它少量代码就可以高效地实现高级应用场景。
3.5　Kafka/Jafka Kafka是Apache下的一个子项目，是一个高性能跨语言分布式发布/订阅消息队列系统，而Jafka是在Kafka之上孵化而来的，即Kafka的一个升级版。具有以下特性：快速持久化，可以在O(1)的系统开销下进行消息持久化；高吞吐，在一台普通的服务器上既可以达到10W/s的吞吐速率；完全的分布式系统，Broker、Producer、Consumer都原生自动支持分布式，自动实现负载均衡；支持Hadoop数据并行加载，对于像Hadoop的一样的日志数据和离线分析系统，但又要求实时处理的限制，这是一个可行的解决方案。Kafka通过Hadoop的并行加载机制统一了在线和离线的消息处理。Apache Kafka相对于ActiveMQ是一个非常轻量级的消息系统，除了性能非常好之外，还是一个工作良好的分布式系统。
四、Kafka中的术语解释 4.1　概述 在深入理解Kafka之前，先介绍一下Kafka中的术语。下图展示了Kafka的相关术语以及之间的关系：</description>
    </item>
    
    <item>
      <title></title>
      <link>/%E6%95%B0%E6%8D%AE%E5%BA%93/couchdb/%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/%E6%95%B0%E6%8D%AE%E5%BA%93/couchdb/%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3/</guid>
      <description>CouchDB允许多个主服务器</description>
    </item>
    
    <item>
      <title></title>
      <link>/%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch/%E8%AF%B4%E6%98%8E/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch/%E8%AF%B4%E6%98%8E/</guid>
      <description>#存储和查询文本 ElasticSearch</description>
    </item>
    
    <item>
      <title></title>
      <link>/%E6%95%B0%E6%8D%AE%E5%BA%93/mongo/mongodb%E6%9F%A5%E8%AF%A2%E6%A1%88%E4%BE%8B/mac%E5%AE%89%E8%A3%85/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/%E6%95%B0%E6%8D%AE%E5%BA%93/mongo/mongodb%E6%9F%A5%E8%AF%A2%E6%A1%88%E4%BE%8B/mac%E5%AE%89%E8%A3%85/</guid>
      <description>一. 安装 下载 mongodb-macos-x86_64-4.2.3.tgz
1. 解压文件 tar -zxvf mongodb-macos-x86_64-4.2.3.tgz
2. 新建mongodb文件夹 mkdir -p mongodb
3. 将mongodb拷贝到新文件夹 cp -R -n /Users/mac/work/mongodb
安装默认路径：/Users/mac/work/mongodb
二. 运行 1.创建数据库存储目录/Users/mac/work/mgdb： sudo mkdir -p /Users/mac/work/mgdb
2.启动mongod mongod
如果上一步自定义了存储路径则需要使用 &amp;ndash;dbpath ，例如 mongod &amp;ndash;dbpath /Users/mac/work/mgdb
如果没有创建全局路径 PATH，需要进入以下目录 cd /Users/mac/work/mongodb/bin &amp;amp;&amp;amp; ./mgdb
#三.安装软件 Studio 3T https://segmentfault.com/a/1190000021033718</description>
    </item>
    
    <item>
      <title></title>
      <link>/%E6%95%B0%E6%8D%AE%E5%BA%93/mongo/%E9%83%A8%E7%BD%B2/replicaset/replicaset/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/%E6%95%B0%E6%8D%AE%E5%BA%93/mongo/%E9%83%A8%E7%BD%B2/replicaset/replicaset/</guid>
      <description>1.三台服务器
服务器1:211.149.189.65:47007 服务器2:211.149.189.65:47008 服务器3:211.149.189.65:47009
2.对应三个配置 mongodb_p.conf mongodb_s1.conf mongodb_s2.conf
3.启动 ./mongod -f /opt/mongodb5/mongodb_p.conf ./mongod -f /opt/mongodb5/mongodb_s1.conf ./mongod -f /opt/mongodb5/mongodb_s2.conf
4.初始化 链接数据库 ./mongod mongodb://211.149.189.65:47007
1.配置replica set节点
config = {_id:&amp;ldquo;repmore&amp;rdquo;,members:[{_id:0,host:&amp;lsquo;211.149.189.65:47007&amp;rsquo;,priority :2},{_id:1,host:&amp;lsquo;211.149.189.65:47008&amp;rsquo;,priority:1},{_id:2,host:&amp;lsquo;211.149.189.65:47009&amp;rsquo;,priority:1}]}
2.初始化replica set
rs.initiate(config);
3.查看replica set各节点状态
rs.status();
5. 生成key
sudo openssl rand -base64 741 &amp;raquo; mt.key
修改权限 chmod 600 mt.key
写到配置文件 auth=true keyFile=/opt/mongodb5/mt.key</description>
    </item>
    
    <item>
      <title></title>
      <link>/%E6%95%B0%E6%8D%AE%E5%BA%93/mongo/%E9%83%A8%E7%BD%B2/setpwd/%E8%AE%BE%E7%BD%AE%E5%AF%86%E7%A0%81/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/%E6%95%B0%E6%8D%AE%E5%BA%93/mongo/%E9%83%A8%E7%BD%B2/setpwd/%E8%AE%BE%E7%BD%AE%E5%AF%86%E7%A0%81/</guid>
      <description>地址
1. show dbs 在mongodb新版本里并没有admin数据库，但是并不妨碍第2步操作。
2. use admin 进入admin数据库
3. 创建管理员账户
db.createUser({ user: &amp;ldquo;mtadmin&amp;rdquo;, pwd: &amp;ldquo;adminmt&amp;rdquo;, roles: [{ role: &amp;ldquo;userAdminAnyDatabase&amp;rdquo;, db: &amp;ldquo;admin&amp;rdquo; }] })
mongodb中的用户是基于身份role的，该管理员账户的 role是 userAdminAnyDatabase。 ‘userAdmin’代表用户管理身份，’AnyDatabase’ 代表可以管理任何数据库。
4. 验证第3步用户添加是否成功
db.auth(&amp;ldquo;mtadmin&amp;rdquo;, &amp;ldquo;adminmt&amp;rdquo;) 如果返回1，则表示成功。 exit退出系统
db.auth()方法理解为 用户的验证功能
5. 修改配置
sudo vi /etc/mongod.conf 找到#security: 取消注释，修改为：
authorization: enabled #注意缩进，缩进参照配置文件其他配置。缩进错误可能第6步重启不成功。
6. 重启 mongodb sudo service mongod restart
7. 进入mongodb,用第3步的 管理员账户登录，用该账户创建其他数据库管理员账号 db.auth(&amp;ldquo;mtadmin&amp;rdquo;, &amp;ldquo;adminmt&amp;rdquo;)
8. 新建你需要管理的mongodb 数据的账号密码。 db.createUser({ user: &amp;ldquo;appadmin&amp;rdquo;, pwd: &amp;ldquo;cluNPP2P6JR5ogKB&amp;rdquo;, roles: [{ role: &amp;ldquo;dbOwner&amp;rdquo;, db: &amp;ldquo;app&amp;rdquo; }] })</description>
    </item>
    
    <item>
      <title></title>
      <link>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c/readme/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/dart_flutter/dart%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/dart_flutter/dart%E5%9F%BA%E7%A1%80/</guid>
      <description>dart官网 Flutter学习笔记&amp;ndash;Dart基础
一.数据类型 Dart中所有东西都是对象, 包括数字、函数等 它们都继承自Object, 并且默认值都是null(包括数字)因此数字、字符串都可以调用各种方法
注意： 默认值 dart中未初始化的值都是null，即使是数字也是一个对象。 fianl 和 const 当你不想让变量可以再次改变的时候用final或const修饰，如下：
String 一组UTF-16单元序列. 字符串赋值的时候, 可以使用单引号, 也可以使用双引号 使用三个单引号或者三个双引号可以多行字符串赋值
Number int：整数值不大于64位 double：64位双精度浮点数
Boolean 使用bool类型表示布尔值.
List 列表, 也叫数组, 常见的添加、索引、删除等方法
Set 集合在Dart中无序的, 并且每个元素具有唯一性, 因为它是无序的, 因此不能像List那样用索引来访问元素
Map 映射, 也称之为字典, Map是一个无序的键值对容器
7.Runes UTF-32字符集的字符串对象
8.符号 Symbols 在Dart程序中，Symbol对象表示声明运算符或标识符。您可能从来不会使用到Symbol，但是它们在按名字引用标识符的API非常有用，因为缩小到改变标识符名称而不更改标识符。 获取标识符的symbol，使用sybol表达式，只需#号后跟标识符：
二.函数
函数定义 函数也是对象, 当没有指定返回值的时候, 函数返回null
函数别名 普通的函数定义. 在赋值之后, 会丢失函数签名信息
可选参数 Dart中支持两种可选参数: 命名可选参数和位置可选参数, 但是两种可选参数不能同时使用 命名可选参数使用大括号{}, 大括号外的参数是必填参数, 大括号内的参数可以指定0个或多个, 并与顺序无关, 在调用函数的时候需要指明参数名, 没有赋值的参数为null 位置可选参数使用中括号[], 在位置可选参数的函数中, 中括号内的参数可以指定0个或多个, 在调用的时候, 参数值会依次按顺序赋值
4.闭包 特性： 1、一个 闭包 是一个方法对象。 2、闭包定义在其他方法的内部，一般通过return将其作为返回值返回。 3、不管闭包对象（方法返回的）在何处被调用，该对象都可以访问其（即闭包所在的方法）作用域内的变量，并持有其状态。</description>
    </item>
    
    <item>
      <title></title>
      <link>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/dart_flutter/flutter%E5%AE%89%E8%A3%85/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/dart_flutter/flutter%E5%AE%89%E8%A3%85/</guid>
      <description>1. [!] Android toolchain - develop for Android devices (Android SDK 28.0.3)问题解决
解决办法
cd 到自己sdk的路径 例如 cd /Users/admin/dev/Android/sdk cd tools cd bin // 以上三行是进入到自己到sdk目录文件夹下 //执行这句才是关键，它会提示你去允许认证 sdkmanager &amp;ndash;licenses 然后一路按y
還需要在用户环境变量下把 路径为 自己 sdk路径 名字为 ANDROID_HOME
然后重启 再创建一个模拟器 ，这样四项都为 - [ ✔ ] 最后在检查下flutter doctor 就ok了
vim ~/.zshrc source ~/.zshrc
#AndroidSdk export ANDROID_HOME=/Volumes/macdata/andriod/sdk
2. ✗ CocoaPods not installed. sudo gem install cocoapods
3. ERROR: Error installing cocoapods:
iOS：解决pod的Insecure world writable dir问题 sudo chmod go-w /Volumes/macdata/go</description>
    </item>
    
    <item>
      <title></title>
      <link>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/third/swaggo/%E8%AF%B4%E6%98%8E/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/third/swaggo/%E8%AF%B4%E6%98%8E/</guid>
      <description>#安装swag命令行 $ go get -u github.com/swaggo/swag/cmd/swag
1.16 及以上版本 $ go install github.com/swaggo/swag/cmd/swag@latest
#运行swag init 查询参数 swag init -h
#支持的Web框架 gin echo buffalo net/http
#与Gin集成 ##1.导入包 import &amp;ldquo;github.com/swaggo/gin-swagger&amp;rdquo; // gin-swagger middleware import &amp;ldquo;github.com/swaggo/files&amp;rdquo; // swagger embed files
##2.在main.go源代码中添加通用的API注释： ##3.在Handler代码中添加API操作注释： ##4.swag init ##5.运行程序，然后在浏览器中访问 http://localhost:8080/swagger/index.html
#声明式注释格式
通用API信息
注释 说明 示例 title 必填 应用程序的名称。 // @title Swagger Example API version 必填 提供应用程序API的版本。 // @version 1.0 description 应用程序的简短描述。 // @description This is a sample server celler server.</description>
    </item>
    
    <item>
      <title></title>
      <link>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E6%96%87%E7%AB%A0/golang%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%95%E6%93%8E%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E6%96%87%E7%AB%A0/golang%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%95%E6%93%8E%E4%BB%8B%E7%BB%8D/</guid>
      <description>学习参考 学习路线 GO每日一库 Golang分类 一些插件案例 一些源码析
资源 基于gnet网络框架编写的各种常见服务端server程序，可以用来学习和快速使用 一款基于gnet开发的RPC微服务框架 rpc服务在游戏中的简单运用 大型多人在线游戏服务器架构设计 大型多人在线游戏服务器架构设计 origin 一个协议驱动的游戏服务器架构设计 开源游戏服务器框架NoahFrame分享：第一章 游戏服务器的进化 游戏服务端究竟解决了什么问题？ 游戏通信协议设计文档 游戏服务器设计 游戏开发—协议设计
#1.GoWorld – 用Golang写一个分布式可扩展、可热更的游戏服务器 https://github.com/xiaonanln/goworld
2.golang Leaf 游戏服务器框架简介 https://blog.csdn.net/kaitiren/article/details/78442454 https://github.com/name5566/leafserver
3.cellnet cellnet好像使用callback回调方式, 直接pass. https://studygolang.com/p/cellnet
4.mqant mqant使用了mqtt协议, 感觉写了太多, 有点复杂, 也pass了. https://golangtc.com/t/58b4e772b09ecc2e18000305 http://www.mqant.com/topic/58d4c895cf36add6408d2c0e https://github.com/liangdas/mqantserver
5.nano https://github.com/lonng/nano nanoserver 有房卡麻将例子 https://github.com/lonng/nanoserver
6.中小型手机棋牌网络游戏服务端架构设计 https://github.com/panshiqu/framework https://blog.csdn.net/panshiqu/article/details/74572133 https://blog.csdn.net/panshiqu/article/details/70160325
7.基于Go语言的棋牌游戏框架 https://github.com/gochenzl/chess
8.房卡麻将棋牌解决方案 https://github.com/shuimuliang https://my.oschina.net/u/3653577/blog/1512057 https://github.com/shuimuliang/qnmahjongserver https://github.com/shuimuliang/qnmahjongclient
9.railgun https://blog.csdn.net/easy_mind/article/details/53260574 https://github.com/3zheng/railgun
10.为互联网IT人打造的中文版awesome-go https://github.com/hackstoic/golang-open-source-projects
11.网络框架之-thrift http://thrift.apache.org/tutorial/go
12.awesome-go:一个很全的go语言框架，库，软件合集 http://hao.jobbole.com/awesome-go/
13. https://github.com/yinjimmy/chessAndCard-2dx https://github.com/shuimuliang/qnmahjongserver
agones agones 源码 官网网站 agones 中文文档 gaming-agones-demo agones</description>
    </item>
    
    <item>
      <title></title>
      <link>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E6%96%87%E7%AB%A0/ziyuan/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E6%96%87%E7%AB%A0/ziyuan/</guid>
      <description>https://gowalker.org/</description>
    </item>
    
    <item>
      <title></title>
      <link>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E8%AF%AD%E8%A8%80/golang%E8%AF%AD%E8%A8%80%E5%87%A0%E4%B8%AA%E6%9C%80%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E7%9A%84%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E8%AF%AD%E8%A8%80/golang%E8%AF%AD%E8%A8%80%E5%87%A0%E4%B8%AA%E6%9C%80%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E7%9A%84%E6%80%BB%E7%BB%93/</guid>
      <description>3.channel channel通道主要是为了进行同步，当一个资源需要共享时用channel就可以在goroutine之间确保同步交换数据。 channel有两种：无缓冲通道和有缓冲通道，区别还得从它的创建开始讲。
在go中使用到make函数的地方主要就是： 1：slice的创建 2：map的创建 3：channel的创建
无缓冲通道只有在发送，接受同时准备好的时侯才能实现操作，否则会导致先执行的操作阻塞等待。
互斥锁 读写互斥锁</description>
    </item>
    
    <item>
      <title></title>
      <link>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/html/css/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/html/css/</guid>
      <description>#CSS讲解 CSS 教程 看这一篇就够了,css选择器知识汇总 前端 -＞ js原生选择器,jQuery选择器 基本选择器(ID选择器,元素选择器,类名选择器,复合选择器,通配符选择器) css思维导图及简单知识点 CSS思维导图 CSS思维导图(自己梳理)
##JS JS所有类型选择器,包括父子兄弟等</description>
    </item>
    
    <item>
      <title></title>
      <link>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/rust/%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/rust/%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3/</guid>
      <description>#文档
Rust布道者张汉东倾授，入门Rust初学者都要攻破哪些难点？ Rust 程序设计语言 简体中文版 Rust宏编程新手指南
区块链技术书单推荐，最后一本值得推荐给所有程序员阅读
通过例子学 Rust</description>
    </item>
    
    <item>
      <title></title>
      <link>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/vue/%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/vue/%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3/</guid>
      <description>#参考文档
官方网站 vue.js_v3教程 视频教程</description>
    </item>
    
    <item>
      <title>alert</title>
      <link>/shortcodes/alert/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/shortcodes/alert/</guid>
      <description>The alert shortcode allow you to highlight information in your page. They create a colored box surrounding your text, like this:
This is an alert !Usage Parameter Default Description theme info success, info,warning,danger Tips : setting only the theme as argument works too : {{%alert warning%}} instead of {{%alert theme=&amp;quot;warning&amp;quot;%}}
Basic examples {{% alert theme=&amp;quot;info&amp;quot; %}}**this** is a text{{% /alert %}}{{% alert theme=&amp;quot;success&amp;quot; %}}**Yeahhh !** is a text{{% /alert %}}{{% alert theme=&amp;quot;warning&amp;quot; %}}**Be carefull** is a text{{% /alert %}}{{% alert theme=&amp;quot;danger&amp;quot; %}}**Beware !</description>
    </item>
    
    <item>
      <title>attachments</title>
      <link>/shortcodes/attachments/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/shortcodes/attachments/</guid>
      <description>The Attachments shortcode displays a list of files attached to a page. Example : AttachmentsBachGavotteShort.mp3(357 kB)Carroll_AliceAuPaysDesMerveilles.pdf(175 kB)adivorciarsetoca00cape.pdf(361 kB)hugo.png(17 kB)movieselectricsheep-flock-244-32500-2.mp4(340 kB)Usage The shortcurt lists files found in a specific folder. Currently, it support two implementations for pages
If your page is a markdown file, attachements must be place in a folder named like your page and ending with .files.
content _index.</description>
    </item>
    
    <item>
      <title>button</title>
      <link>/shortcodes/button/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/shortcodes/button/</guid>
      <description>Display an actionable button in your page.
This is a warning button Usage Parameter Default Description href &amp;quot;&amp;quot; The location href to link to align &amp;ldquo;center&amp;rdquo; horizontal align button on page theme primary default, primary , success,info,warning,danger The inner text you place in short code will be displayed as the button text
Demo {{&amp;lt; button href=&amp;quot;https://google.com&amp;quot; &amp;gt;}} go to google {{&amp;lt; /button &amp;gt;}}{{&amp;lt; button href=&amp;quot;https://google.com&amp;quot; theme=&amp;quot;success&amp;quot; &amp;gt;}} Success {{&amp;lt; /button &amp;gt;}}{{&amp;lt; button href=&amp;quot;https://google.</description>
    </item>
    
    <item>
      <title>Credits</title>
      <link>/credits/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/credits/</guid>
      <description>github contributors @vjeantet247 commits@matcornic45 commits@W-Floyd24 commits@Pilskalns24 commits@lierdakil16 commits@Marthym13 commits@gwleclerc9 commits@jose-oc8 commits@siamkreative6 commits@Xipas5 commits@FMuro2 commits@joepvd2 commits@EnigmaCurry2 commits@Yoann-M2 commits@aral2 commits@adamlamar1 commits@byzheng1 commits@zivbk11 commits@danielfbm1 commits@damoon1 commits@vielmetti1 commits@erikjasiak1 commits@giuliov1 commits@farmergreg1 commits@JOduMonT1 commits@tarpdalton1 commits@jamestharpe1 commits@JohnBlood1 commits@kamilchm1 commits@lgfischer1 commits@ripienaar1 commits@rsanderscybraics1 commits@shazic1 commits@viertaxa1 commits@uweschaefer1 commits@rabadiw1 commits@wshayes1 commits@eyoder1 commits@ivan-danilov1 commits@karlmacklin1 commits@petzi531 commits@remi310001 commits@tonivj51 commitsOther contribution @bepsupports and advices@facette.</description>
    </item>
    
    <item>
      <title>Disable features</title>
      <link>/content-organisation/customize-style/disable/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/content-organisation/customize-style/disable/</guid>
      <description>You can disable feature in docdock by changing some params in config.toml
hide Next / Prev Chevrons [params]disableNavChevron = true hide Search box in side menu [params]disableSearch = true hide the icon in side bar [params]disableHomeIcon = true </description>
    </item>
    
    <item>
      <title>Docdock-built Sites</title>
      <link>/showcase/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/showcase/</guid>
      <description>https://invincible.site/ by @shazic https://bitfan.io/ by @vjeantet </description>
    </item>
    
    <item>
      <title>excerpt</title>
      <link>/shortcodes/excerpt/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/shortcodes/excerpt/</guid>
      <description>The Excerpt shortcode is used to mark a part of a page&amp;rsquo;s content for re-use. Defining an excerpt enables other shortcodes, such as the excerpt-include shortcode, to display the marked content elsewhere.
You can only define one excerpt per page. In other words, you can only add the Excerpt shortcode once to a page.Usage Parameter Default Description hidden &amp;ldquo;false&amp;rdquo; Controls whether the page content contained in the Excerpt shortcode placeholder is displayed on the page.</description>
    </item>
    
    <item>
      <title>excerpt-include</title>
      <link>/shortcodes/excerpt-include/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/shortcodes/excerpt-include/</guid>
      <description>The Excerpt Include shortcode is used to display &amp;rsquo;excerpted&amp;rsquo; (that is, a segment of) content from one page in another. Before you can use this shortcode, the excerpt must have been defined using the Excerpt shortcode. Note that you can have more than one Excerpt Include shortcode on a page (although you can have only one Excerpt shortcode on a page).Usage Parameter Default Description filename required Type the filename of the page that contains the excerpt to be displayed.</description>
    </item>
    
    <item>
      <title>expand</title>
      <link>/shortcodes/expand/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/shortcodes/expand/</guid>
      <description>The Expand shortcode displays an expandable/collapsible section of text on your page. Here is an example
Expand me...Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmodtempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodoconsequat. Duis aute irure dolor in reprehenderit in voluptate velit essecillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat nonproident, sunt in culpa qui officia deserunt mollit anim id est laborum.</description>
    </item>
    
    <item>
      <title>icon</title>
      <link>/shortcodes/icon/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/shortcodes/icon/</guid>
      <description>Display an icon like It uses :
glyphicons library (bootstrap).more info here fontawesome library more info here This icon shortcode will display an icon in your page.
Usage Parameter Default Description name required name of icon (see bellow) size none size of icon, medium, xx-small, x-small, small, large, x-large, xx-large, 11px, 2em, 20%&amp;hellip;. Tips : setting only the name as argument works too : {{&amp;lt;icon film&amp;gt;}} instead of {{&amp;lt;icon name=&amp;quot;film&amp;quot;&amp;gt;}}</description>
    </item>
    
    <item>
      <title>mermaid</title>
      <link>/shortcodes/mermaid/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/shortcodes/mermaid/</guid>
      <description>Flowchart example Show code ...{{}}graph LR;A[Hard edge] --&gt;|Link text| B(Round edge)B --&gt; C{Decision}C --&gt;|One| D[Result one]C --&gt;|Two| E[Result two]{{&lt; /mermaid &gt;}}graph LR;A[Hard edge] --&gt;|Link text| B(Round edge)B --&gt; C{Decision}C --&gt;|One| D[Result one]C --&gt;|Two| E[Result two]With sub-graphs and some style Show code...{{}}graph LR;X --&gt; YlinkStyle 0 stroke:#f00,stroke-width:4px;Y --&gt; ZZ --&gt; XlinkStyle 1,2 interpolate basis stroke:#0f0,stroke-width:2px;X --&gt; A1subgraph rightA2 --&gt; B2B2 --&gt; C2endsubgraph leftA1 --&gt; B1B1 --&gt; C1endC1 --&gt; XZ --&gt; A2C2 --&gt; Zstyle Y fill:#f9f,stroke:#333,stroke-width:4pxclassDef left fill:#ccf,stroke:#f66,stroke-width:2px,stroke-dasharray: 5, 5class A1,B1,C1 left{{&amp;lt; /mermaid &amp;gt;}}graph LR;X --&gt; YlinkStyle 0 stroke:#f00,stroke-width:4px;Y --&gt; ZZ --&gt; XlinkStyle 1,2 interpolate basis stroke:#0f0,stroke-width:2px;X --&gt; A1subgraph rightA2 --&gt; B2B2 --&gt; C2endsubgraph leftA1 --&gt; B1B1 --&gt; C1endC1 --&gt; XZ --&gt; A2C2 --&gt; Zstyle Y fill:#f9f,stroke:#333,stroke-width:4pxclassDef left fill:#ccf,stroke:#f66,stroke-width:2px,stroke-dasharray: 5, 5class A1,B1,C1 leftSequence example Show code .</description>
    </item>
    
    <item>
      <title>notice</title>
      <link>/shortcodes/notice/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/shortcodes/notice/</guid>
      <description>The notice shortcode shows 4 types of disclaimers to help you structure your page.
Note {{% notice note %}}A notice disclaimer{{% /notice %}}renders as
A notice disclaimer
Info {{% notice info %}}An information disclaimer{{% /notice %}}renders as
An information disclaimer
Tip {{% notice tip %}}A tip disclaimer{{% /notice %}}renders as
A tip disclaimer
Warning {{% notice warning %}}An warning disclaimer{{% /notice %}}renders as</description>
    </item>
    
    <item>
      <title>page test</title>
      <link>/shortcodes/children/test/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/shortcodes/children/test/</guid>
      <description>This is a test demo child page</description>
    </item>
    
    <item>
      <title>page test 3</title>
      <link>/shortcodes/children/children-2/test3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/shortcodes/children/children-2/test3/</guid>
      <description>This is a test 3 demo child page</description>
    </item>
    
    <item>
      <title>panel</title>
      <link>/shortcodes/panel/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/shortcodes/panel/</guid>
      <description>The panel shortcodeAllow you to highlight information or put it in a box. They create a colored box surrounding your textUsage Parameter Default Description header none The title of the panel. If specified, this title will be displayed in its own header row. footer none the footer of the panel. If specified, this text will be displayed in its own row theme primary default,primary,info,success,warning,danger Basic example By default :</description>
    </item>
    
    <item>
      <title>qqqq</title>
      <link>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E8%AF%AD%E8%A8%80/qqq/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E8%AF%AD%E8%A8%80/qqq/</guid>
      <description>1.需要修改接收者中的值 2.接收者是拷贝代价比较大的大对象 3.保证一致性，如果有某个方法使用了指针接收者，那么其他的方法也应该使用指针接收者。</description>
    </item>
    
    <item>
      <title>revealjs</title>
      <link>/shortcodes/revealjs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/shortcodes/revealjs/</guid>
      <description>This shortcode will format the enclosed markdow to render it with reveal.js at runtime (client-side)
Read more on revealjs github repo.
Usage revealjs can use the following named parameters :
theme
transition
controls
progress
history
center
ImportantEven if the enclosed content is a mardown, use `&lt;` shortcode notation instead of the `%` notation Content formating and slide delimiters read more on this here
Demo # In the morning___## Getting up- Turn off alarm- Get out of bed___## Breakfast- Eat eggs- Drink coffee---# In the evening___## Dinner- Eat spaghetti- Drink wine___## Going to sleep- Get in bed- Count sheepSee it fullscreenSource : Show code .</description>
    </item>
    
    <item>
      <title>Theme styles</title>
      <link>/content-organisation/customize-style/themestyle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/content-organisation/customize-style/themestyle/</guid>
      <description>In site configuration file, you can set a subtheme name of this theme to load a specific css.
add a param themeStyle = &amp;quot;STYLE_NAME&amp;quot; in the [params] part of config.toml file.
Style &amp;ldquo;original&amp;rdquo; [params]themeStyle = &amp;#34;original&amp;#34; Style &amp;ldquo;flex&amp;rdquo; (work in progress) [params]themeStyle = &amp;#34;flex&amp;#34; </description>
    </item>
    
    <item>
      <title>Theme variants</title>
      <link>/content-organisation/customize-style/theme-variants/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/content-organisation/customize-style/theme-variants/</guid>
      <description>In site configuration file, you can set a variant name of this theme to load a specific css, with different color specifications.
add a param themeVariant = &amp;quot;VARIANT_NAME&amp;quot; in the [params] part of config.toml file.
Available variants change only colors at this momentVariant &amp;ldquo;gray&amp;rdquo; [params]themeVariant = &amp;#34;gray&amp;#34; Variant &amp;ldquo;gold&amp;rdquo; [params]themeVariant = &amp;#34;gold&amp;#34; Variant &amp;ldquo;green&amp;rdquo; [params]themeVariant = &amp;#34;green&amp;#34;` </description>
    </item>
    
    <item>
      <title>参考文档</title>
      <link>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E8%AF%AD%E8%A8%80/%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E8%AF%AD%E8%A8%80/%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3/</guid>
      <description>基础 地鼠文档
Go语言实现与标准库
Go 语言设计与实现
Go 语言中文开源图书、资料或文档
go语言中文文档
基础视频教学
Go 语言高性能编程
Golang应该掌握哪些必要的知识点才能算掌握golang这门语言？
sync Go 语言设计与实现-6.2 同步原语与锁
sync - 处理同步需求
golang的sync包
浅谈 Golang sync 包的相关使用方法
go开源仓库
面试题 go语言面试题 golang面试题整理 Golang面试题41道 golang 面试题整理 Go 语言笔试面试题汇总 golang 关键知识点 golang知识点整理(持续更新) 好的站点 综合博客 </description>
    </item>
    
    <item>
      <title>知识点</title>
      <link>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E8%AF%AD%E8%A8%80/%E7%9F%A5%E8%AF%86%E7%82%B9/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E8%AF%AD%E8%A8%80/%E7%9F%A5%E8%AF%86%E7%82%B9/</guid>
      <description>系统中断信号注册 通道接收多个返回值 go context reflect 通过反射，我们可以获取一个结构体类型的字段,也可以获取一个类型的导出方法，这样我们就可以在运行时了解一个类型的结构，这是一个非常强大的功能。 另外 Golang 有一些特别先进的特性，需要说道说道。
✔ 用户态线程 / 绿色线程 / 协程（goroutine） ✔ 语言级多路复用（select） ✔ 信道（channel） ✔ 通信顺序进程 (CSP) ✔ 读写锁（RWMutex） ✔ context、defer ✔ 组合继承 ✔ 函数多返回值</description>
    </item>
    
    <item>
      <title>重点知识</title>
      <link>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E8%AF%AD%E8%A8%80/%E9%87%8D%E7%82%B9%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E8%AF%AD%E8%A8%80/%E9%87%8D%E7%82%B9%E7%9F%A5%E8%AF%86/</guid>
      <description>知识体系可以从字段，函数，结构体入手，再到详细编码的逻辑结构，也就是面向过程进行加深。然后是指针，异常机制，IO，并发等。有了基本架构之后才是网络，后台等高级特性。
字段： 1.数据操作。包括基本数据类型的定义以及操作，运算，切片等。注意指针。 2.字段在结构体中可以是匿名字段。 3.array，map，slice是高级结构体。array是数组，而slice针对数组进行的切片处理。map是映射。使用range遍历。 4.平行赋值i,j=i+1,j+1.这个一般用在if中。
结构体： 1.结构体的定义。在go中类是结构体与函数叠加而成。而结构体就是算法与结构中的“结构”。 2.type用于重定义数据，定义结构体，接口。 3.go更加接近理论，所以在go中类，方法，变量，被叫做结构体，函数，字段。.
函数： 1.函数的定义。在go中都是函数，而属于结构体的函数可以称为方法。 2.函数有匿名函数。 3.func funcName(input1 type1, input2 type2) (output1 type1, output2 type2) { //这里是处理逻辑代码 //返回多个值 return value1, value2 } 字段和返回字段可以简化。如input1,input2 type。这其实就是如果当前没有就往后面找。 4.注意变参func（arg&amp;hellip;int）
流程控制： 1.if参照了for，可以使用；分号隔开，前面的是变量声明。 2.switch的case后面自带break，想要往下执行需要使用fallthrough。switch跟的语句如果没有添加，那么就是true。 3.for格式如果省略了分号，那么就相当于while。for range可以用于读取slice和map的数据。 4.goto是跳转语句。
指针： 1.string,slice,map都是基于指针的机制了，可以直接传递，不需要再取地址传指针操作。但是注意slice的长度发生变化的话，仍需取地址传指针。 2.结构体指针函数的使用需要注意。
表达式： 1.go不支持三元表达式。也就是说一个n:=expr?trueV:falseV在这里不能使用。
异常： 1.go中，异常处理使用panic()，recover()，defer联合使用。panic抛出异常中断，如果想要回复，可以在defer中使用recover恢复。但是go中，尽量少用异常处理。
IO： 1.go中使用make()创建切片，映射，程道。返回对象，而new()返回的是指针。 2.chan分为有缓冲和无缓冲两种。 3.chan作为线程件通信的IO通道。 4.常使用select，case，default组合chan进行操作。
并发： 1.并发里面主要是多线程以及常用的辅助类等。 2.并发的内容一般包含： （1）线程的初始化。线程的实现是go xxx，这个过程叫做gorutine。 （2）线程的通信。通过channel进行通信。注意，这里channel本身是具有锁功能的，往往作为最简单常用的锁进行使用 （3）线程对于资源的操作。这里主要是同步异步，阻塞和非阻塞等概念。 同步异步的关键在于互斥，而阻塞和非阻塞关键在于锁。但是两者其实很接近。 所以往往出现的是互斥锁。这里常用的是sync.Mutext.Lock()实现互斥锁。使用lock.Lock()实现锁。runtime模块往往用于运行时候的一些操作，帮助线程实现让出时间片，线程退出等操作。atomic模块是原子操作。其他的一些类和函数是基于这些概念进行的扩展。 （4）defer使用 defer func_name(param-list) 当一个函数调用前有关键字 defer 时, 那么这个函数的执行会推迟到包含这个 defer 语句的函数即将返回前才执行 defer 调用的函数参数的值在 defer 定义时就确定了, 而 defer 函数内部所使用的变量的值需要在这个函数运行时才确定。defer 函数调用的执行时机是外层函数设置返回值之后, 并且在即将返回之前</description>
    </item>
    
    <item>
      <title>重点解析</title>
      <link>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E8%AF%AD%E8%A8%80/%E9%87%8D%E7%82%B9%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/%E8%AF%AD%E8%A8%80/%E9%87%8D%E7%82%B9%E8%A7%A3%E6%9E%90/</guid>
      <description>channal channel 数据结构 阻塞、非阻塞操作 多路select 1.channel 是结构 2.channel 结构里包含一个循环缓冲区 3.channel 有等待队列
4.channel 的阻塞与非阻塞操作 5.多路的select 处理逻辑
Golang合辑
Golang深入理解GPM模型
https://github.com/aceld 1.调度器由来 2.调度器GMP模型设计思想 3.调度器GMP调度场景的调度全过程分析 4.掌握go调度器原理</description>
    </item>
    
  </channel>
</rss>
